

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Getting Started &mdash; django_twitter 1.0.0 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="django_twitter.models" href="models.html" />
    <link rel="prev" title="Installation" href="installation.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> django_twitter
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Table of Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Getting Started</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#configuration">Configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#twitter-api-credentials">Twitter API credentials</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-collection-commands">Data collection commands</a></li>
<li class="toctree-l2"><a class="reference internal" href="#profile-sets">Profile sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="#loading-in-a-set-screen-names-or-twitter-ids">Loading in a set screen names or Twitter IDs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#checking-accounts-with-django-verifications">Checking accounts with Django Verifications</a></li>
<li class="toctree-l2"><a class="reference internal" href="#checking-accounts-with-django-twitter-s-built-in-utilities">Checking accounts with Django Twitter’s built-in utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="#profile-snapshots">Profile snapshots</a></li>
<li class="toctree-l2"><a class="reference internal" href="#followers-and-followings-lists">Followers and followings lists</a></li>
<li class="toctree-l2"><a class="reference internal" href="#error-codes-and-historical-accounts">Error codes and historical accounts</a></li>
<li class="toctree-l2"><a class="reference internal" href="#collecting-tweets-and-backfilling">Collecting Tweets and “backfilling”</a></li>
<li class="toctree-l2"><a class="reference internal" href="#checking-tweet-coverage">Checking tweet coverage</a></li>
<li class="toctree-l2"><a class="reference internal" href="#streaming-api">Streaming API</a></li>
<li class="toctree-l2"><a class="reference internal" href="#exporting-data">Exporting data</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="models.html">Abstract Models</a></li>
<li class="toctree-l1"><a class="reference internal" href="commands.html">Management Commands</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">django_twitter</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Getting Started</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/getting_started.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="getting-started">
<h1>Getting Started<a class="headerlink" href="#getting-started" title="Permalink to this headline">¶</a></h1>
<div class="section" id="configuration">
<h2>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h2>
<p>Django Twitter is not designed to be a standalone app - rather, it is
designed to provide abstract models for you to import and implement in
your own Django app. This gives you more flexibility when it comes to
creating relations between the Twitter data you collect and other models
in your app, and allows you to expand the models with additional custom
fields as needed. For example, one our projects consists of an extensive
database of members of Congress and other politicians, including their
Twitter profiles. Using Django Twitter abstract models, we can define a
standard template for storing Twitter profile data, but also expand it
with a foreign key to associate profiles with particular politicians in
our database, like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django_twitter.models</span> <span class="kn">import</span> <span class="n">AbstractTwitterProfile</span>

<span class="k">class</span> <span class="nc">TwitterProfile</span><span class="p">(</span><span class="n">AbstractTwitterProfile</span><span class="p">):</span>
    <span class="n">politician</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;Politician&quot;</span><span class="p">,</span> <span class="n">related_name</span><span class="o">=</span><span class="s2">&quot;twitter_profiles&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>To implement Django Twitter models in your app, you simply need to
import the abstract models you wish to create in your own app’s
<code class="docutils literal notranslate"><span class="pre">models.py</span></code> file. If you don’t want to make any modifications to the
models, you can simply implement them as defined, like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django_twitter.models</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">class</span> <span class="nc">TwitterProfile</span><span class="p">(</span><span class="n">AbstractTwitterProfile</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">TwitterProfileSnapshot</span><span class="p">(</span><span class="n">AbstractTwitterProfileSnapshot</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">Tweet</span><span class="p">(</span><span class="n">AbstractTweet</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">TwitterFollowerList</span><span class="p">(</span><span class="n">AbstractTwitterFollowerList</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">TwitterFollowingList</span><span class="p">(</span><span class="n">AbstractTwitterFollowingList</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">TwitterHashtag</span><span class="p">(</span><span class="n">AbstractTwitterHashtag</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">TwitterPlace</span><span class="p">(</span><span class="n">AbstractTwitterPlace</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">TweetSet</span><span class="p">(</span><span class="n">AbstractTweetSet</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="k">class</span> <span class="nc">TwitterProfileSet</span><span class="p">(</span><span class="n">AbstractTwitterProfileSet</span><span class="p">):</span>
    <span class="k">pass</span>

<span class="o">**</span><span class="n">NOTE</span> <span class="n">FOR</span> <span class="n">DEVELOPERS</span><span class="p">:</span><span class="o">**</span> <span class="n">Because</span> <span class="n">Django</span> <span class="n">Twitter</span> <span class="n">models</span> <span class="n">are</span> <span class="n">abstract</span>
<span class="ow">and</span> <span class="n">get</span> <span class="n">implemented</span> <span class="n">within</span> <span class="n">your</span> <span class="n">own</span> <span class="n">app</span><span class="p">,</span> <span class="n">Django</span> <span class="n">Twitter</span> <span class="n">doesn</span><span class="s1">&#39;t have</span>
<span class="nb">any</span> <span class="n">clue</span> <span class="n">where</span> <span class="n">its</span> <span class="n">models</span> <span class="n">actually</span> <span class="n">live</span> <span class="ow">and</span> <span class="n">what</span> <span class="n">they</span><span class="s1">&#39;re called.</span>
<span class="n">Because</span> <span class="n">of</span> <span class="n">this</span><span class="p">,</span> <span class="n">Django</span> <span class="n">Twitter</span> <span class="n">creates</span> <span class="n">relations</span> <span class="n">between</span> <span class="n">your</span> <span class="n">app</span><span class="s1">&#39;s</span>
<span class="n">implementations</span> <span class="n">of</span> <span class="n">its</span> <span class="n">models</span> <span class="ow">in</span> <span class="n">a</span> <span class="n">somewhat</span> <span class="n">unconventional</span> <span class="n">way</span><span class="p">:</span> <span class="nb">all</span>
<span class="n">of</span> <span class="n">the</span> <span class="n">abstract</span> <span class="n">models</span> <span class="ow">in</span> <span class="n">Django</span> <span class="n">Twitter</span> <span class="n">inherit</span> <span class="kn">from</span> <span class="nn">an</span>
<span class="sb">``</span><span class="n">AbstractTwitterBase</span><span class="sb">``</span> <span class="k">class</span> <span class="nc">that</span> <span class="n">has</span> <span class="n">a</span> <span class="n">custom</span> <span class="sb">``</span><span class="fm">__new__</span><span class="sb">``</span> <span class="n">function</span>
<span class="n">that</span> <span class="n">adds</span> <span class="n">relations</span> <span class="n">to</span> <span class="n">your</span> <span class="n">concrete</span> <span class="n">models</span> <span class="n">at</span> <span class="n">runtime</span><span class="p">,</span> <span class="n">when</span> <span class="n">they</span>
<span class="n">get</span> <span class="n">initialized</span><span class="o">.</span> <span class="n">Since</span> <span class="n">this</span> <span class="n">happens</span> <span class="n">when</span> <span class="n">Django</span> <span class="n">itself</span> <span class="n">first</span>
<span class="n">initializes</span><span class="p">,</span> <span class="sb">``</span><span class="n">AbstractTwitterBase</span><span class="sb">``</span> <span class="n">objects</span> <span class="n">are</span> <span class="n">able</span> <span class="n">to</span>
<span class="bp">self</span><span class="o">-</span><span class="n">recognize</span> <span class="n">themselves</span> <span class="ow">and</span> <span class="n">create</span> <span class="n">their</span> <span class="n">own</span> <span class="n">relations</span><span class="p">,</span> <span class="n">which</span>
<span class="n">Django</span> <span class="n">recognizes</span> <span class="k">as</span> <span class="n">though</span> <span class="n">they</span> <span class="n">had</span> <span class="n">been</span> <span class="n">included</span> <span class="ow">in</span> <span class="n">the</span> <span class="n">model</span>
<span class="n">definitions</span> <span class="n">directly</span><span class="o">.</span> <span class="n">Unless</span> <span class="n">you</span> <span class="n">want</span> <span class="n">to</span> <span class="n">make</span> <span class="n">changes</span> <span class="n">directly</span> <span class="n">to</span>
<span class="n">Django</span> <span class="n">Twitter</span><span class="s1">&#39;s abstract models as a developer, this should have no</span>
<span class="n">impact</span> <span class="n">on</span> <span class="n">how</span> <span class="n">you</span> <span class="n">use</span> <span class="n">Django</span> <span class="n">Twitter</span><span class="o">.</span> <span class="n">But</span> <span class="k">if</span> <span class="n">you</span> <span class="n">do</span> <span class="n">wish</span> <span class="n">to</span> <span class="n">modify</span>
<span class="ow">or</span> <span class="n">expand</span> <span class="n">relations</span> <span class="n">between</span> <span class="nb">any</span> <span class="n">of</span> <span class="n">the</span> <span class="n">abstract</span> <span class="n">models</span> <span class="n">defined</span> <span class="ow">in</span>
<span class="n">Django</span> <span class="n">Twitter</span><span class="p">,</span> <span class="n">you</span> <span class="n">will</span> <span class="n">need</span> <span class="n">to</span> <span class="n">do</span> <span class="n">so</span> <span class="n">by</span> <span class="n">editing</span> <span class="n">the</span> <span class="sb">``</span><span class="fm">__new__</span><span class="sb">``</span>
<span class="n">function</span> <span class="n">on</span> <span class="sb">``</span><span class="n">AbstractTwitterBase</span><span class="sb">``</span><span class="o">.</span>
</pre></div>
</div>
<p>Then, in your <code class="docutils literal notranslate"><span class="pre">settings.py</span></code> file, you simply need to add
<code class="docutils literal notranslate"><span class="pre">django_twitter</span></code> to your <code class="docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code> and define a single
additional settings variable that tells Django Twitter the name of the
app that implements the abstract models, like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">TWITTER_APP</span> <span class="o">=</span> <span class="s2">&quot;my_app&quot;</span>
</pre></div>
</div>
<p>Once you’ve done this, you just need to run
<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">manage.py</span> <span class="pre">makemigrations</span> <span class="pre">my_app</span></code> and
<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">manage.py</span> <span class="pre">migrate</span></code> to create the tables in your database.
You’re now ready to start collecting and storing Twitter data. To do so,
you just need to call one of Django Twitter’s data collection commands.</p>
</div>
<div class="section" id="twitter-api-credentials">
<h2>Twitter API credentials<a class="headerlink" href="#twitter-api-credentials" title="Permalink to this headline">¶</a></h2>
<p>All of the data collection commands in Django Twitter accept your
Twitter API access tokens and secrets directly as parameters:
<code class="docutils literal notranslate"><span class="pre">--api_key</span></code>, <code class="docutils literal notranslate"><span class="pre">--api_secret</span></code>, <code class="docutils literal notranslate"><span class="pre">--access_token</span></code>,
<code class="docutils literal notranslate"><span class="pre">--access_secret</span></code>. However, the Pewhooks <code class="docutils literal notranslate"><span class="pre">TwitterAPIHandler</span></code> that
Django Twitter uses also looks for your API credentials in environment
variables, and this is the preferred way to manage your credentials. If
you define the following variables, Django Twitter and Pewhooks will
automatically detect your credentials: <code class="docutils literal notranslate"><span class="pre">TWITTER_API_KEY</span></code>,
<code class="docutils literal notranslate"><span class="pre">TWITTER_API_SECRET</span></code>, <code class="docutils literal notranslate"><span class="pre">TWITTER_API_ACCESS_TOKEN</span></code>,
<code class="docutils literal notranslate"><span class="pre">TWITTER_API_ACCESS_SECRET</span></code>.</p>
</div>
<div class="section" id="data-collection-commands">
<h2>Data collection commands<a class="headerlink" href="#data-collection-commands" title="Permalink to this headline">¶</a></h2>
<p>Django Twitter provides a set of Django management commands to cover all
of your data collection needs; collecting data outside of these commands
is not officially supported and not recommended. You can call these
commands using the CLI, for example:
<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">manage.py</span> <span class="pre">django_twitter_get_profile</span> <span class="pre">MY_TWITTER_ID_OR_SCREEN_NAME</span></code>.</p>
<p>Or you can call them programmatically using Django’s <code class="docutils literal notranslate"><span class="pre">call_command</span></code>
function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.core.management</span> <span class="kn">import</span> <span class="n">call_command</span>
<span class="n">call_command</span><span class="p">(</span><span class="s2">&quot;django_twitter_get_profile&quot;</span><span class="p">,</span> <span class="n">MY_TWITTER_ID_OR_SCREEN_NAME</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="profile-sets">
<h2>Profile sets<a class="headerlink" href="#profile-sets" title="Permalink to this headline">¶</a></h2>
<p>In the example models above, you may have noticed a model called
<code class="docutils literal notranslate"><span class="pre">TwitterProfileSet</span></code> that does not correspond to any data type that can
be collected from the Twitter API. This is a model that exists in Django
Twitter to make it easier to track lists of Twitter profiles. The model
is extremely simple - it consists entirely of an arbitrary <code class="docutils literal notranslate"><span class="pre">name</span></code>
field and a many-to-many relation on the model in your app that inherits
from <code class="docutils literal notranslate"><span class="pre">AbstractTwitterProfile</span></code>. All of the management commands that
Django Twitter provides that collect data on Twitter profiles have
implementations that can be run on a set of profiles all at once, to
make it easier to do bulk data collection. For example, the
<code class="docutils literal notranslate"><span class="pre">django_twitter_get_profile</span></code> command collects profile data for a
specific Twitter account, and the <code class="docutils literal notranslate"><span class="pre">django_twitter_get_profile_set</span></code>
does the exact same thing, except for a list of accounts that are
associated with a <code class="docutils literal notranslate"><span class="pre">TwitterProfileSet</span></code> in your database. Similarly, you
can run <code class="docutils literal notranslate"><span class="pre">django_twitter_get_profile_tweets</span></code> on a single Twitter
account, or you can run <code class="docutils literal notranslate"><span class="pre">django_twitter_get_profile_set_tweets</span></code> to
loop over and collect the timelines for an entire set of accounts (more
on this below).</p>
</div>
<div class="section" id="loading-in-a-set-screen-names-or-twitter-ids">
<h2>Loading in a set screen names or Twitter IDs<a class="headerlink" href="#loading-in-a-set-screen-names-or-twitter-ids" title="Permalink to this headline">¶</a></h2>
<p>While Django Twitter has support for sampling tweets directly using the
Streaming API, most of our projects here at Pew typically focus on a
specific list of Twitter accounts, for which we collect profile and
tweet data on a regular basis.</p>
<p>If you have a set of screen names or Twitter IDs and you wish to collect
data for them using Django Twitter, there are two correct ways to do
this. The easiest approach is to use Django Twitter’s built-in commands:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.core.management</span> <span class="kn">import</span> <span class="n">call_command</span>
<span class="n">call_command</span><span class="p">(</span><span class="s2">&quot;django_twitter_get_profile&quot;</span><span class="p">,</span> <span class="n">MY_TWITTER_ID_OR_SCREEN_NAME</span><span class="p">)</span>
</pre></div>
</div>
<p>As with all Django management commands, you can also call the command
directly from the CLI by running
<code class="docutils literal notranslate"><span class="pre">python</span> <span class="pre">manage.py</span> <span class="pre">django_twitter_get_profile</span> <span class="pre">MY_TWITTER_ID_OR_SCREEN_NAME</span></code></p>
<p>Running the <code class="docutils literal notranslate"><span class="pre">django_twitter_get_profile</span></code> command allows you to pass
either a Twitter ID or screen name, and it will correctly handshake with
the API and create the record properly. You can then look up the record
like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># If you were using a Twitter ID:</span>
<span class="kn">from</span> <span class="nn">myapp.models</span> <span class="kn">import</span> <span class="n">MyTwitterProfileModel</span>
<span class="n">profile</span> <span class="o">=</span> <span class="n">MyTwitterProfileModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">twitter_id</span><span class="o">=</span><span class="n">MY_TWITTER_ID</span><span class="p">)</span>

<span class="c1"># If you were using a screen name:</span>
<span class="kn">from</span> <span class="nn">myapp.models</span> <span class="kn">import</span> <span class="n">MyTwitterProfileModel</span>
<span class="n">profile</span> <span class="o">=</span> <span class="n">MyTwitterProfileModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">screen_name</span><span class="o">=</span><span class="n">MY_SCREEN_NAME</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
</pre></div>
</div>
<p>If you’re working with a lot of IDs or screen names, it’s probably
easier to create a TwitterProfileSet (described above) to track all of
the profiles you’ll be creating. You can do this easily by passing a
unique name for your collection of profiles when running the
get_profile command:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django.core.management</span> <span class="kn">import</span> <span class="n">call_command</span>
<span class="n">call_command</span><span class="p">(</span><span class="s2">&quot;django_twitter_get_profile&quot;</span><span class="p">,</span> <span class="n">MY_TWITTER_ID_OR_SCREEN_NAME</span><span class="p">,</span> <span class="n">add_to_profile_set</span><span class="o">=</span><span class="s2">&quot;my_profile_set&quot;</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">myapp.models</span> <span class="kn">import</span> <span class="n">MyTwitterProfileSetModel</span>
<span class="n">profiles</span> <span class="o">=</span> <span class="n">MyTwitterProfileSetModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s2">&quot;my_profile_set&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">profiles</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>The advantage to using a profile set is that it allows you to run
commands on all of the profiles at once, such as collecting the latest
data from the API:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">call_command</span><span class="p">(</span><span class="s2">&quot;django_twitter_get_profile_set&quot;</span><span class="p">,</span> <span class="s2">&quot;my_profile_set&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The second alternative approach is to create the profiles manually using
the Django ORM. If you do this and you’re using a list of screen names,
you need to first look up the unique Twitter ID from the API before
creating the record:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pewhooks.twitter</span> <span class="kn">import</span> <span class="n">TwitterAPIHandler</span>
<span class="kn">from</span> <span class="nn">django_twitter.utils</span> <span class="kn">import</span> <span class="n">get_twitter_profile_json</span><span class="p">,</span> <span class="n">get_twitter_profile</span>
<span class="kn">from</span> <span class="nn">myapp.models</span> <span class="kn">import</span> <span class="n">MyTwitterProfileModel</span>

<span class="c1"># Initialize a Pewhooks TwitterAPIHandler</span>
<span class="n">twitter</span> <span class="o">=</span> <span class="n">TwitterAPIHandler</span><span class="p">()</span>
<span class="c1"># Grab the profile from the API, so you have it&#39;s actual Twitter ID</span>
<span class="n">twitter_json</span> <span class="o">=</span> <span class="n">get_twitter_profile_json</span><span class="p">(</span><span class="n">SCREEN_NAME</span><span class="p">,</span> <span class="n">twitter</span><span class="p">)</span>
<span class="k">if</span> <span class="n">twitter_json</span><span class="p">:</span>
    <span class="c1"># Create or fetch the profile</span>
    <span class="c1"># get_twitter_profile creates the profile if it doesn&#39;t already exist, but it ONLY WORKS ON TWITTER IDS</span>
    <span class="n">profile</span> <span class="o">=</span> <span class="n">get_twitter_profile</span><span class="p">(</span><span class="n">twitter_json</span><span class="o">.</span><span class="n">id_str</span><span class="p">,</span> <span class="n">create</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c1"># Alternatively you can just do this directy from the API, although get_twitter_profile is preferred</span>
    <span class="n">profile</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">MyTwitterProfileModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get_or_create</span><span class="p">(</span><span class="n">twitter_id</span><span class="o">=</span><span class="n">twitter_json</span><span class="o">.</span><span class="n">id_str</span><span class="p">)</span>
</pre></div>
</div>
<p>If the second option above seems somewhat tedious, that’s because it’s
intended to be. <em>Twitter screen names are recyclable, so they are NOT an
effective way for tracking Twitter profiles.</em> If an account that you’re
tracking gets deleted, someone else can create a new account with the
same username. If you’re using the screen name to query the API, you
could very easily wind up collecting data for an entirely different
account without noticing it. Screen name recycling isn’t often a major
concern for your average run-of-the-mill Twitter account, but it’s
something that happens <em>very</em> frequently for prominent accounts like,
for example, prominent members of Congress that leave office and delete
their official PR accounts. Users can also change their screen names at
any time - also something that isn’t very common among your typical
Twitter users, but something that <em>does</em> happen fairly frequently with
politicians who, for example, might change their handle from
<code class="docutils literal notranslate"><span class="pre">JudyForCongress</span></code> to <code class="docutils literal notranslate"><span class="pre">CongresswomanJudy</span></code> when they get elected.</p>
<p>For these reasons, Django Twitter tracks accounts using their canonical,
unique Twitter IDs instead of screen names. It’s perfectly fine to call
the <code class="docutils literal notranslate"><span class="pre">django_twitter_get_profile</span></code> command with a screen name when you
first load in an account (as long as you’re sure that the screen name
isn’t outdated), but we recommend immediately switching to the account’s
canonical <code class="docutils literal notranslate"><span class="pre">twitter_id</span></code> as soon as you’ve collected profile data for
the first time. Better yet, you can use Django Twitter’s
<code class="docutils literal notranslate"><span class="pre">TwitterProfileSet</span></code> model to track a list of accounts once you’ve
loaded them in, and it will always use the <code class="docutils literal notranslate"><span class="pre">twitter_id</span></code> field to
collect data.</p>
</div>
<div class="section" id="checking-accounts-with-django-verifications">
<h2>Checking accounts with Django Verifications<a class="headerlink" href="#checking-accounts-with-django-verifications" title="Permalink to this headline">¶</a></h2>
<p>If you’re loading in a list of accounts from an external data source,
you might not have any choice but to use screen names - unfortunately,
the practice of using Twitter IDs instead of screen names is not as
common as it should be, so sometimes screen names are all you have. If
that’s the case, it’s possible that some of the screen names in your
list have already been recycled before you even start your data
collection, so it’s good practice to take a look at the profile data you
get back from the API after you first load in a set of accounts, to make
sure that each account is actually, for example, a politician, and not a
spam bot that snatched up a politician’s old username.</p>
<p>To help with this endeavor, it can be useful to also install Django
Verifications, which provides a lightweight interface for verifying the
accuracy of important records in your database. We use Django
Verifications in concert with Django Twitter to manually review and
confirm Twitter profiles that we <em>think</em> belong to politicians. Every
time we start tracking an account and link it to a politician in our
database (using a foreign key that we added to our implementation of the
<code class="docutils literal notranslate"><span class="pre">AbstractTwitterProfile</span></code> model), Django Verifications queues it up for
manual review. To do this, we simply have to install
<code class="docutils literal notranslate"><span class="pre">django_verifications</span></code> by adding it to your <code class="docutils literal notranslate"><span class="pre">INSTALLED_APPS</span></code> in
<code class="docutils literal notranslate"><span class="pre">settings.py</span></code>, define a few extra fields in your Twitter profile
model’s <code class="docutils literal notranslate"><span class="pre">Meta</span></code> attributes, and have your model inherit from
<code class="docutils literal notranslate"><span class="pre">django_verifications.models.VerifiedModel</span></code> as well as
<code class="docutils literal notranslate"><span class="pre">django_twitter.models.AbstractTwitterProfile</span></code>, like so:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django_twitter.models</span> <span class="kn">import</span> <span class="n">AbstractTwitterProfile</span>
<span class="kn">from</span> <span class="nn">django_verifications.models</span> <span class="kn">import</span> <span class="n">VerifiedModel</span>

<span class="k">class</span> <span class="nc">TwitterProfile</span><span class="p">(</span><span class="n">AbstractTwitterProfile</span><span class="p">,</span> <span class="n">VerifiedModel</span><span class="p">):</span>
    <span class="n">politician</span> <span class="o">=</span> <span class="n">models</span><span class="o">.</span><span class="n">ForeignKey</span><span class="p">(</span><span class="s2">&quot;Politician&quot;</span><span class="p">,</span> <span class="n">related_name</span><span class="o">=</span><span class="s2">&quot;twitter_profiles&quot;</span><span class="p">)</span>
    <span class="k">class</span> <span class="nc">Meta</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
        <span class="n">unique_together</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;twitter_id&quot;</span><span class="p">,</span> <span class="s2">&quot;politician&quot;</span><span class="p">)</span>
        <span class="n">fields_to_verify</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;politician&quot;</span><span class="p">]</span>
        <span class="n">verification_filters</span> <span class="o">=</span> <span class="p">[{</span><span class="s2">&quot;politician__isnull&quot;</span><span class="p">:</span> <span class="bp">False</span><span class="p">}]</span>
</pre></div>
</div>
</div>
<div class="section" id="checking-accounts-with-django-twitter-s-built-in-utilities">
<h2>Checking accounts with Django Twitter’s built-in utilities<a class="headerlink" href="#checking-accounts-with-django-twitter-s-built-in-utilities" title="Permalink to this headline">¶</a></h2>
<p>Even if you don’t want to go to the trouble of setting up Django
Verifications, it can still be a good idea to spot-check your data using
some of Django Twitter’s utility functions. Often, when screen names are
recycled and claimed by a new account, the new account is distinctively
different than the prior owner (e.g. a politician’s old handle getting
picked up by a spam bot that constantly tweets about bitcoin) - so we
can sometimes find bad accounts simply by looking for unusual content.
Given a QuerySet of profiles, Django Twitter has two functions that
calculate the average similarity of each profile against all others,
using either the profiles’ descriptions, or a sample of recent tweets.
Here, Justin Bieber easily stands out in comparison to our Pew Research
Center accounts:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span>from django_twitter.utils import identify_unusual_profiles_by_descriptions
most_similar, most_unique = identify_unusual_profiles_by_descriptions(profiles)
&gt;&gt;&gt; most_unique
  twitter_id     snapshots__description  avg_cosine
5   27260086  JUSTICE the album out now    0.163522

from django_twitter.utils import identify_unusual_profiles_by_tweet_text
most_similar, most_unique = identify_unusual_profiles_by_tweet_text(profiles)
&gt;&gt;&gt; most_unique
   twitter_id                                         tweet_text  avg_cosine
10   27260086  RT @MIAFestival: LINEUP ALERT!\nJustin Bieber,...    0.508597
</pre></div>
</div>
</div>
<div class="section" id="profile-snapshots">
<h2>Profile snapshots<a class="headerlink" href="#profile-snapshots" title="Permalink to this headline">¶</a></h2>
<p>Since profile attributes (e.g. screen names, descriptions) and profile
stats (e.g. follower counts) can change over time, Django Twitter stores
all of that mutable data in “snapshots” that represent what a profile
looked like at a particular point in time. Every time you collect data
on a profile - by running one of Django Twitter’s data collection
commands like <code class="docutils literal notranslate"><span class="pre">django_twitter_get_profile</span></code> - a new record will be
created in your app’s snapshot model that inherits from
<code class="docutils literal notranslate"><span class="pre">AbstractTwitterProfileSnapshot</span></code>. Snapshots are associated with their
profile through the <code class="docutils literal notranslate"><span class="pre">snapshots</span></code> relation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">profile</span> <span class="o">=</span> <span class="n">MyTwitterProfileModel</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">twitter_id</span><span class="o">=</span><span class="s2">&quot;12345&quot;</span><span class="p">)</span>
<span class="n">profile</span><span class="o">.</span><span class="n">snapshots</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
</pre></div>
</div>
<p>And, for convenience, the most recent snapshot is also made available
directly through the <code class="docutils literal notranslate"><span class="pre">most_recent_snapshot</span></code> foreign key, updated each
time a new snapshot is collected:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">profile</span><span class="o">.</span><span class="n">most_recent_snapshot</span>
</pre></div>
</div>
</div>
<div class="section" id="followers-and-followings-lists">
<h2>Followers and followings lists<a class="headerlink" href="#followers-and-followings-lists" title="Permalink to this headline">¶</a></h2>
<p>In a similar vein, Django Twitter also stores data on profiles’
followers and followings (“friends”) in separate lists every time they
are collected from the API. These lists are defined by
<code class="docutils literal notranslate"><span class="pre">AbstractTwitterFollowerList</span></code> and <code class="docutils literal notranslate"><span class="pre">AbstractTwitterFollowingList</span></code>.
Because collecting the follower lists for extremely popular Twitter
accounts can be a hugely time-consuming process that can span hours or
even days (during which time you could encounter errors that
accidentally stop data collection prematurely), the follower and
following list models each contain a <code class="docutils literal notranslate"><span class="pre">start_time</span></code> and <code class="docutils literal notranslate"><span class="pre">finish_time</span></code>
field for tracking the period during which the list was collected. In
addition to these two fields, these list objects also contain a foreign
key to the <code class="docutils literal notranslate"><span class="pre">profile</span></code> for whom the list was collected, and a
many-to-many relation to <code class="docutils literal notranslate"><span class="pre">followers</span></code> or <code class="docutils literal notranslate"><span class="pre">followings</span></code> containing all
of the profiles in the list.</p>
<p>Since this is a somewhat complicated (albeit necessary) way to store all
of this data, the <code class="docutils literal notranslate"><span class="pre">AbstractTwitterProfile</span></code> model provides some
shortcut functions to grab the profile’s most recent lists:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">profile</span><span class="o">.</span><span class="n">current_followers</span><span class="p">()</span>
<span class="n">profile</span><span class="o">.</span><span class="n">current_follower_list</span><span class="p">()</span>
<span class="n">profile</span><span class="o">.</span><span class="n">current_followings</span><span class="p">()</span>
<span class="n">profile</span><span class="o">.</span><span class="n">current_following_list</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="section" id="error-codes-and-historical-accounts">
<h2>Error codes and historical accounts<a class="headerlink" href="#error-codes-and-historical-accounts" title="Permalink to this headline">¶</a></h2>
<p>If Django Twitter encounters an error when attempting to collect a
Twitter profile, it will store the error code in the
<code class="docutils literal notranslate"><span class="pre">twitter_error_code</span></code> field. For example, accounts that have been
suspended will return Code 63, and accounts that have been deleted by
their owner will return Code 50. Details on specific error codes can be
found in Twitter’s developer documentation:
<a class="reference external" href="https://developer.twitter.com/ja/docs/basics/response-codes">https://developer.twitter.com/ja/docs/basics/response-codes</a></p>
<p>It can often be useful to add some custom logic to your application to
determine what to do with profiles that have started to return an error
code; for example, you may want to skip data collection for deleted
accounts, etc. Django Twitter also provides a <code class="docutils literal notranslate"><span class="pre">historical</span></code> boolean
field on the <code class="docutils literal notranslate"><span class="pre">AbstractTwitterProfile</span></code> model that can be used as a
conditional flag in your app for determining whether or not to run a
data collection command for a particular profile. Django Twitter doesn’t
do anything with this field itself, it exists purely as an optional
convenience for you.</p>
</div>
<div class="section" id="collecting-tweets-and-backfilling">
<h2>Collecting Tweets and “backfilling”<a class="headerlink" href="#collecting-tweets-and-backfilling" title="Permalink to this headline">¶</a></h2>
<p>You can collect recent tweets for a profile (or a set of profiles) by
running the <code class="docutils literal notranslate"><span class="pre">django_twitter_get_profile_tweets</span></code> (or
<code class="docutils literal notranslate"><span class="pre">django_twitter_get_profile_set_tweets</span></code>) command. Django Twitter uses
Pewhooks and the Twitter v1 API to collect the tweets produced by an
account in reverse-chronological order, up to a maximum of that
profile’s most recent ~3200 tweets. Doing this requires pagination to
iterate through a profile’s tweet history, and each page consumes some
of your API quota - so it makes sense to only iterate through the full
list the first time you begin collecting a profile’s tweets. Once you’ve
gone back as far as the API will allow, you’re typically only interested
in keeping up with new tweets. To that end, Django Twitter sets a
<code class="docutils literal notranslate"><span class="pre">tweet_backfilled</span></code> flag on each <code class="docutils literal notranslate"><span class="pre">AbstractTwitterProfile</span></code> object, to
track whether you’ve successfully collected all of the historically
available tweets for each profile. Once you have run
<code class="docutils literal notranslate"><span class="pre">django_twiter_get_profile_tweets</span></code> on a profile and completed this
backfill process, Django Twitter will set the backfill flag to <code class="docutils literal notranslate"><span class="pre">True</span></code>
and the next time you run that command, it will break off data
collection when it encounters a tweet that has already been previously
collected. To override this behavior, you can simply pass the
<code class="docutils literal notranslate"><span class="pre">--ignore-backfill</span></code> flag to the command, or use the
<code class="docutils literal notranslate"><span class="pre">max_backfill_date</span></code> or <code class="docutils literal notranslate"><span class="pre">max_backfill_days</span></code> parameters to specify how
far back you would like to go, and the <code class="docutils literal notranslate"><span class="pre">--overwrite</span></code> flag to specify
whether you want to update existing tweets with the latest API data. The
latter parameters can be useful if you would like to update tweets’
engagement stats (e.g. likes and retweets) for a short period of time
after they have been created - but don’t want to unnecessarily iterate
through older tweets whose engagement is unlikely to have changed.</p>
</div>
<div class="section" id="checking-tweet-coverage">
<h2>Checking tweet coverage<a class="headerlink" href="#checking-tweet-coverage" title="Permalink to this headline">¶</a></h2>
<p>Depending on how often an account tweets, the ~3200 historical tweets
offered by the Twitter v1 API may provide you with years of data, or
just a mere week’s worth. When analyzing a set of profiles together - as
we typically do - it’s important to assess how far back your backfilling
attempts actually got for the profiles you want to analyze, and
determine the timeframe over which you actually have complete data.
Django Twitter has two utility functions to assist with this process.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">get_monthly_twitter_activity</span></code> function takes a QuerySet of
profiles and a date range, and returns a Pandas DataFrame that contains
one row for each account, and columns that contain the total tweets that
exist in the database for that account in each month in your time range.
If you load this into Excel and set conditional formatting to highlight
months with low counts, it’s relatively easy to tell the date ranges
that were covered by your backfilling vs. where you’re missing data for
certain accounts.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django_twitter.utils</span> <span class="kn">import</span> <span class="n">get_monthly_twitter_activity</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">get_monthly_twitter_activity</span><span class="p">(</span>
    <span class="n">profiles</span><span class="p">,</span>
    <span class="n">START_DATE</span><span class="p">,</span>
    <span class="n">max_date</span><span class="o">=</span><span class="n">END_DATE</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># &gt;&gt;&gt; df.head()</span>
<span class="c1">#      2020_10  2020_11  2020_12  2021_1  2021_2  2021_3  2021_4  2021_5  \</span>
<span class="c1"># 8.0      0.0      0.0      0.0     1.0     0.0     0.0     3.0     5.0</span>
<span class="c1"># 0.0      0.0      0.0      0.0     0.0     0.0     0.0     0.0     1.0</span>
<span class="c1"># 3.0      1.0      0.0      0.0     0.0     0.0     0.0     0.0    11.0</span>
<span class="c1"># 1.0      0.0      0.0      0.0     0.0     0.0     0.0     0.0     0.0</span>
<span class="c1"># 6.0      0.0      0.0      0.0     0.0     0.0     0.0     6.0    38.0</span>
<span class="c1">#</span>
<span class="c1">#      2021_6   pk    screen_name          created_at                     name</span>
<span class="c1"># 8.0    39.0  1.0    pewresearch 2009-03-03 10:39:39      Pew Research Center</span>
<span class="c1"># 0.0    36.0  2.0      pewglobal 2012-09-18 12:08:41      Pew Research Global</span>
<span class="c1"># 3.0    24.0  3.0     pewmethods 2015-02-09 16:00:41     Pew Research Methods</span>
<span class="c1"># 1.0    35.0  4.0  pewjournalism 2010-02-04 09:42:57  Pew Research Journalism</span>
<span class="c1"># 6.0     2.0  5.0       facttank 2013-03-13 18:41:33   Pew Research Fact Tank</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">find_missing_date_ranges</span></code> gives you a slightly different view of
your missing data, intended to highlight periods where there may be
unnatural gaps in the timeseries (i.e. due to data collection failure,
etc.) This function returns a dataframe that lists time periods longer
than <code class="docutils literal notranslate"><span class="pre">min_consecutive_missing_dates</span></code> where no tweets exist for a
particular account in the database.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django_twitter.utils</span> <span class="kn">import</span> <span class="n">find_missing_date_ranges</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">find_missing_date_ranges</span><span class="p">(</span>
    <span class="n">profiles</span><span class="p">,</span>
    <span class="n">START_DATE</span><span class="p">,</span>
    <span class="n">max_date</span><span class="o">=</span><span class="n">END_DATE</span><span class="p">,</span>
    <span class="n">min_consecutive_missing_dates</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
<span class="p">)</span>
<span class="c1"># &gt;&gt;&gt; results.head()</span>
<span class="c1">#     twitter_id  start_date    end_date  range</span>
<span class="c1"># 3    111339670  2021-01-01  2021-06-07    157</span>
<span class="c1"># 11  1262729180  2021-01-01  2021-05-27    146</span>
<span class="c1"># 28    17071048  2021-01-01  2021-05-21    140</span>
<span class="c1"># 0    831470472  2021-01-01  2021-05-19    138</span>
<span class="c1"># 12    36462231  2021-01-01  2021-05-18    137</span>
</pre></div>
</div>
</div>
<div class="section" id="streaming-api">
<h2>Streaming API<a class="headerlink" href="#streaming-api" title="Permalink to this headline">¶</a></h2>
<p>TODO</p>
</div>
<div class="section" id="exporting-data">
<h2>Exporting data<a class="headerlink" href="#exporting-data" title="Permalink to this headline">¶</a></h2>
<p>TODO: get_tweet_dataframe</p>
<p>Since we often conduct research on tweets as well as profile attributes,
and want to capture a representation of each tweet’s authoring profile
<em>as it existed at the time of the tweet</em>, Django Twitter also provides a
handy functions for extracting a Pandas DataFrame of a profile’s
snapshots over a particular timeframe. This function has support for
linear interpolation, so you can approximate and fill in gaps for days
where you didn’t collect any profile data.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">START_DATE</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">END_DATE</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">2021</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">31</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">profile</span><span class="o">.</span><span class="n">get_snapshots</span><span class="p">(</span>
    <span class="n">START_DATE</span><span class="p">,</span>
    <span class="n">END_DATE</span><span class="p">,</span>
    <span class="n">skip_interpolation</span><span class="o">=</span><span class="bp">False</span>
<span class="p">)</span>
</pre></div>
</div>
<p>You can also fetch a snapshot dataframe for multiple profiles using the
<code class="docutils literal notranslate"><span class="pre">get_twitter_profile_dataframe</span></code> utility function:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">django_twitter.utils</span> <span class="kn">import</span> <span class="n">get_twitter_profile_dataframe</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">get_twitter_profile_dataframe</span><span class="p">(</span>
    <span class="n">profiles</span><span class="p">,</span> <span class="c1"># a QuerySet of Twitter profiles</span>
    <span class="n">START_DATE</span><span class="p">,</span>
    <span class="n">END_DATE</span><span class="p">,</span>
    <span class="n">skip_interpolation</span><span class="o">=</span><span class="bp">False</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="models.html" class="btn btn-neutral float-right" title="django_twitter.models" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="installation.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Pew Research Center

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>